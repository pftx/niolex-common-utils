/**
 * ProxyUtil.java
 *
 * Copyright 2011 Niolex, Inc.
 *
 * Niolex licenses this file to you under the Apache License, version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package org.apache.niolex.commons.reflect;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * The ProxyUtil is help application users to create JDK dynamic proxy for any object. The JDK proxy delegates
 * all the interfaces of the original object, so please program by interface not by concrete class.
 * <p>
 * Since 3.0.1, we refactored this class to make it more useful, and it's not backward compatible.
 * </p>
 * 
 * @author <a href="mailto:xiejiyun@gmail.com">Xie, Jiyun</a>
 * @version 1.0.0
 */
public class ProxyUtil {

    /**
     * The proxy handler is the interceptor interface, so user can do something before and after the method invocation.
     * Users need to implement this interface.
     * 
     * @param <BeforeT> the proxy handler type parameter
     * @see ProxyUtil
     * @author <a href="mailto:xiejiyun@gmail.com">Xie, Jiyun</a>
     * @version 1.0.0
     */
    public static interface ProxyHandler<BeforeT> {

        /**
         * Invoked before the invocation of real method by us.
         *
         * @param host the host object being delegated
         * @param method the method we are going to invoke
         * @param args the arguments to be used to invoke method, or null if the method do not need any argument
         * @return an object of type {@link BeforeT}
         */
        public BeforeT invokeBefore(Object host, Method method, Object[] args);

        /**
         * Invoked after the invocation of real method by us.
         *
         * @param host the host object being delegated
         * @param method the method we just invoked
         * @param args the arguments to be used to invoke method, or null if the method do not need any argument
         * @param ret the result returned from invoking the method, maybe null
         * @param before the object returned by {@link #invokeBefore(Object, Method, Object[])}
         * @return an object to be returned as the return value of the method invocation. If you don't want to change
         *         the method behavior, please return the parameter <code>ret</code>
         */
        public Object invokeAfter(Object host, Method method, Object[] args, Object ret, BeforeT before);

    }

    /**
     * Create a proxy object delegates all the interfaces of the host object. We will invoke the specified proxy handler
     * for every method invocation on the proxy object.
     *
     * @param <T> the return type, must be an interface, not concrete class
     * @param <BeforeT> the proxy handler type parameter
     * @param host the host object to be delegated
     * @param h the proxy handler used to intercept method invocation
     * @return the proxy object generated by JDK
     * @throws ClassCastException if the return type is not an interface
     */
    @SuppressWarnings("unchecked")
    public static final <T, BeforeT> T newProxyInstance(T host, ProxyHandler<BeforeT> h) {
        // Create a new proxy stub for the host object.
        InvocationHandler handler = new ProxyStub<BeforeT>(h, host);
        // Using JDK method to create dynamic proxy.
        Object ret = Proxy.newProxyInstance(ProxyUtil.class.getClassLoader(),
                host.getClass().getInterfaces(), handler);
        // Cast the return object to the specified type.
        return (T)ret;
    }

}

/**
 * Please ignore this class, this is an internal helper class used to create dynamic proxy.
 *
 * @param <BeforeT> the proxy handler type parameter
 * @see ProxyUtil
 * @author <a href="mailto:xiejiyun@gmail.com">Xie, Jiyun</a>
 * @version 1.0.0
 */
class ProxyStub<BeforeT> implements InvocationHandler {
    // The proxy handler.
    private final ProxyUtil.ProxyHandler<BeforeT> handler;
    // The host object to be delegated.
    private final Object host;

    /**
     * The constructor of ProxyStub.
     *
     * @param handler the proxy handler
     * @param host the host object
     */
    public ProxyStub(ProxyUtil.ProxyHandler<BeforeT> handler, Object host) {
        super();
        this.handler = handler;
        this.host = host;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        BeforeT before = handler.invokeBefore(host, method, args);
        Object ret = method.invoke(host, args);
        return handler.invokeAfter(host, method, args, ret, before);
    }

}
